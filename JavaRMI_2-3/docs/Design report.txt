Part of this design was taken from the previous Java RMI lab. CarRentalCompany, CarType, Car, Reservation, Quote, ReservationException and ReservationConstraints remain largely the same, meaning all mentioned classes except Car are Serializable (because they need to be communicated to the customer) and CarRentalCompany is annotated Remote (because it needs to be remotely accessible). The class CarRentalAgency followed very naturally from this structure, since we needed an instance to keep track of all CarRentalCompanies and (un)register them if necessary. At first glance, it would be easy to give CarRentalAgency the responsibility of managing communication with the client.  However, this would give CarRentalAgency 2 distinct responsibilities (communication management AND company lookup/management). We instead created a new class SessionManager to deal with communication related issues and life cycle management of sessions (essentially implementing part of the functionality of Session Beans) and in doing so avoided a cluttered CarRentalAgency class. As a consequence, SessionManager is annotated Remote.
Next up are the sessions themselves. Since managers and clients need to perform different activities, we created two distinct classes, ManagerSession and RentalSession. Shared functionality (e.g. identification, the SessionManager they belong to etc.) are implemented in a superclass Session, following basic OO design principles. Naturally any session needs to be remotely accessible because it provides a mechanism to query information from CarRentalAgency.
In this design we made the assumption that CarRentalAgency and SessionManager run on the same machine. Different instances of CarRentalCompany and Session can run on different machines.

//TODO
Which remote objects are registered via the built-in RMI registry (or not) and why?
Briefly explain the approach you applied to achieve life cycle management of sessions. -> SessionManager zorgt voor alles
At which places is synchronization necessary to achieve thread-safety? Will those places
become a bottleneck by applying synchronization?
